library ieee;
library std;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use std.env.all;
use std.textio.all;
use ieee.std_logic_textio.all;
use work.pkt_pkg.all;
use work.nn_pkg.all;

-- tb_top_e2e.vhd: End-to-end sim (pkt_rx -> tensor_adapter -> hls4ml core -> pkt_tx).
-- Loads INFER_REQ/INFER_RSP vectors from sim/fixtures generated by nn_golden.py.

entity tb_top_e2e is
end entity;

architecture tb of tb_top_e2e is
  constant CLK_PERIOD : time := 10 ns;
  constant TIMEOUT    : time := 5 ms;

  signal clk : std_logic := '0';
  signal rst : std_logic := '1';

  -- Input byte stream to pkt_rx
  signal in_valid : std_logic := '0';
  signal in_ready : std_logic;
  signal in_data  : std_logic_vector(7 downto 0) := (others => '0');

  -- pkt_rx payload stream
  signal rx_out_valid : std_logic;
  signal rx_out_ready : std_logic;
  signal rx_out_data  : std_logic_vector(7 downto 0);
  signal rx_out_last  : std_logic;

  signal rx_pkt_type  : pkt_type_t;
  signal rx_pkt_len   : std_logic_vector(15 downto 0);
  signal rx_pkt_valid : std_logic;
  signal rx_pkt_error : std_logic;

  -- tensor_adapter -> NN
  signal t_valid : std_logic;
  signal t_ready : std_logic := '1';
  signal t_data  : signed(15 downto 0);
  signal t_last  : std_logic;

  -- NN -> tensor_adapter
  signal t_out_valid : std_logic;
  signal t_out_ready : std_logic;
  signal t_out_data  : signed(15 downto 0);
  signal t_out_last  : std_logic;

  -- tensor_adapter -> pkt_tx payload
  signal tx_in_valid : std_logic;
  signal tx_in_ready : std_logic;
  signal tx_in_data  : std_logic_vector(7 downto 0);
  signal tx_in_last  : std_logic;

  -- pkt_tx output byte stream
  signal out_valid : std_logic;
  signal out_ready : std_logic := '1';
  signal out_data  : std_logic_vector(7 downto 0);

  signal tx_start : std_logic := '0';

  -- perf counters (optional for Milestone 6)
  signal cycles : std_logic_vector(31 downto 0);
  signal stalls : std_logic_vector(31 downto 0);
  signal infers : std_logic_vector(31 downto 0);

  type byte_arr_t is array (natural range <>) of std_logic_vector(7 downto 0);
  constant MAX_PKT_LEN : natural := 256;
  constant REQ_PATH : string := "../../../sim/fixtures/nn_in.hex";
  constant RSP_PATH : string := "../../../sim/fixtures/nn_out.hex";
  signal req_pkt : byte_arr_t(0 to MAX_PKT_LEN-1);
  signal rsp_pkt : byte_arr_t(0 to MAX_PKT_LEN-1);
  signal req_len : integer := 0;
  signal rsp_len : integer := 0;

  signal out_count : integer := 0;
  signal rx_seen : std_logic := '0';
  signal tx_seen : std_logic := '0';
  signal in_seen_cnt : integer := 0;
  signal in_seen_done : std_logic := '0';
  signal clk_edges : integer := 0;
  signal in_elem_idx : integer := 0;
  signal out_elem_idx : integer := 0;

  function to_s16(lo_b, hi_b : std_logic_vector(7 downto 0)) return signed is
    variable u : unsigned(15 downto 0);
  begin
    u := (others => '0');
    u(7 downto 0) := unsigned(lo_b);
    u(15 downto 8) := unsigned(hi_b);
    return signed(u);
  end function;

  procedure send_byte(
    signal s_data  : out std_logic_vector(7 downto 0);
    signal s_valid : out std_logic;
    signal s_ready : in  std_logic;
    signal s_clk   : in  std_logic;
    b              : std_logic_vector(7 downto 0)
  ) is
  begin
    s_data  <= b;
    s_valid <= '1';
    wait until rising_edge(s_clk);
    while s_ready = '0' loop
      wait until rising_edge(s_clk);
    end loop;
    s_valid <= '0';
  end procedure;

begin
  clk <= not clk after CLK_PERIOD/2;

  watchdog: process
  begin
    wait for TIMEOUT;
    assert false report "tb_top_e2e timeout" severity failure;
  end process;

  u_rx: entity work.pkt_rx
    generic map (G_CRC_EN => false)
    port map (
      clk => clk,
      rst => rst,
      in_valid => in_valid,
      in_ready => in_ready,
      in_data => in_data,
      out_valid => rx_out_valid,
      out_ready => rx_out_ready,
      out_data => rx_out_data,
      out_last => rx_out_last,
      pkt_type => rx_pkt_type,
      pkt_len => rx_pkt_len,
      pkt_valid => rx_pkt_valid,
      pkt_error => rx_pkt_error
    );

  u_tensor: entity work.tensor_adapter
    generic map (G_DATA_WIDTH => 16)
    port map (
      clk => clk,
      rst => rst,
      in_valid => rx_out_valid,
      in_ready => rx_out_ready,
      in_data => rx_out_data,
      in_last => rx_out_last,
      tensor_valid => t_valid,
      tensor_ready => t_ready,
      tensor_data => t_data,
      tensor_last => t_last,
      tensor_out_valid => t_out_valid,
      tensor_out_ready => t_out_ready,
      tensor_out_data => t_out_data,
      tensor_out_last => t_out_last,
      out_valid => tx_in_valid,
      out_ready => tx_in_ready,
      out_data => tx_in_data,
      out_last => tx_in_last
    );

  u_nn: entity work.hls4ml_wrap
    generic map (G_DATA_WIDTH => 16, G_IN_DIM => 8, G_STUB => false, G_REVERSE_IN => false, G_SWAP_BYTES => false)
    port map (
      clk => clk,
      rst => rst,
      in_valid => t_valid,
      in_ready => t_ready,
      in_data => t_data,
      in_last => t_last,
      out_valid => t_out_valid,
      out_ready => t_out_ready,
      out_data => t_out_data,
      out_last => t_out_last
    );

  u_tx: entity work.pkt_tx
    generic map (G_CRC_EN => false)
    port map (
      clk => clk,
      rst => rst,
      start => tx_start,
      pkt_type => INFER_RSP,
      pkt_len => std_logic_vector(to_unsigned(NN_DATA_WIDTH / 8, 16)),
      in_valid => tx_in_valid,
      in_ready => tx_in_ready,
      in_data => tx_in_data,
      out_valid => out_valid,
      out_ready => out_ready,
      out_data => out_data
    );

  u_cnt: entity work.perf_counters
    port map (
      clk => clk,
      rst => rst,
      stall_pulse => '0',
      infer_pulse => t_out_valid and t_out_ready and t_out_last,
      cycles => cycles,
      stalls => stalls,
      infers => infers
    );

  -- start response when request header is accepted
  process (clk)
  begin
    if rising_edge(clk) then
      if rst = '1' then
        tx_start <= '0';
      else
        tx_start <= '0';
        if rx_pkt_valid = '1' and rx_pkt_type = INFER_REQ and rx_pkt_error = '0' then
          tx_start <= '1';
        end if;
      end if;
    end if;
  end process;

  loader: process
    file f_req : text;
    file f_rsp : text;
    variable line_buf : line;
    variable byte_val : std_logic_vector(7 downto 0);
    variable idx : integer;
  begin
    idx := 0;
    file_open(f_req, REQ_PATH, read_mode);
    while not endfile(f_req) loop
      readline(f_req, line_buf);
      hread(line_buf, byte_val);
      if idx < MAX_PKT_LEN then
        req_pkt(idx) <= byte_val;
        idx := idx + 1;
      end if;
    end loop;
    file_close(f_req);
    assert idx > 0 report "REQ fixture empty or missing (nn_in.hex)" severity failure;
    req_len <= idx;
    report "Loaded REQ bytes: " & integer'image(idx) severity note;

    idx := 0;
    file_open(f_rsp, RSP_PATH, read_mode);
    while not endfile(f_rsp) loop
      readline(f_rsp, line_buf);
      hread(line_buf, byte_val);
      if idx < MAX_PKT_LEN then
        rsp_pkt(idx) <= byte_val;
        idx := idx + 1;
      end if;
    end loop;
    file_close(f_rsp);
    assert idx > 0 report "RSP fixture empty or missing (nn_out.hex)" severity failure;
    rsp_len <= idx;
    report "Loaded RSP bytes: " & integer'image(idx) severity note;
    wait;
  end process;

  monitor: process (clk)
  begin
    if rising_edge(clk) then
      if rst = '1' then
        out_count <= 0;
        out_elem_idx <= 0;
      else
        if out_valid = '1' and out_ready = '1' then
          tx_seen <= '1';
          if out_count < rsp_len then
            if out_data /= rsp_pkt(out_count) then
              report "RSP byte mismatch at index " & integer'image(out_count) &
                " expected=0x" & to_hstring(rsp_pkt(out_count)) &
                " got=0x" & to_hstring(out_data) severity failure;
            end if;
          end if;
          out_count <= out_count + 1;
        end if;
        if t_out_valid = '1' and t_out_ready = '1' then
          if (PKT_HDR_LEN + out_elem_idx*2 + 1) < rsp_len then
            if t_out_data /= to_s16(rsp_pkt(PKT_HDR_LEN + out_elem_idx*2),
                                    rsp_pkt(PKT_HDR_LEN + out_elem_idx*2 + 1)) then
              report "Tensor OUT mismatch at elem " & integer'image(out_elem_idx) &
                " expected=0x" &
                to_hstring(rsp_pkt(PKT_HDR_LEN + out_elem_idx*2 + 1)) &
                to_hstring(rsp_pkt(PKT_HDR_LEN + out_elem_idx*2)) &
                " got=0x" & to_hstring(std_logic_vector(t_out_data(15 downto 8))) &
                to_hstring(std_logic_vector(t_out_data(7 downto 0))) severity failure;
            end if;
          end if;
          out_elem_idx <= out_elem_idx + 1;
        end if;
      end if;
    end if;
  end process;

  input_watch: process (clk)
  begin
    if rising_edge(clk) then
      if rst = '1' then
        in_seen_cnt <= 0;
        in_seen_done <= '0';
        in_elem_idx <= 0;
      else
        if in_valid = '1' then
          if in_seen_done = '0' then
            report "RX byte[" & integer'image(in_seen_cnt) & "] = 0x" &
              to_hstring(in_data) & " (in_ready=" & std_logic'image(in_ready) & ")" severity warning;
            in_seen_cnt <= in_seen_cnt + 1;
            if in_seen_cnt >= 7 then
              in_seen_done <= '1';
            end if;
          end if;
        end if;
        if t_valid = '1' and t_ready = '1' then
          if (PKT_HDR_LEN + in_elem_idx*2 + 1) < req_len then
            if t_data /= to_s16(req_pkt(PKT_HDR_LEN + in_elem_idx*2),
                                req_pkt(PKT_HDR_LEN + in_elem_idx*2 + 1)) then
              report "Tensor IN mismatch at elem " & integer'image(in_elem_idx) &
                " expected=0x" &
                to_hstring(req_pkt(PKT_HDR_LEN + in_elem_idx*2 + 1)) &
                to_hstring(req_pkt(PKT_HDR_LEN + in_elem_idx*2)) &
                " got=0x" & to_hstring(std_logic_vector(t_data(15 downto 8))) &
                to_hstring(std_logic_vector(t_data(7 downto 0))) severity failure;
            end if;
          end if;
          in_elem_idx <= in_elem_idx + 1;
        end if;
        if rx_pkt_error = '1' then
          report "rx_pkt_error asserted" severity warning;
        end if;
      end if;
    end if;
  end process;

  input_watchdog: process
  begin
    wait until rst = '0';
    wait for 1 ms;
    assert clk_edges > 0 report "no clock edges observed" severity failure;
    assert in_seen_cnt > 0 report "no input bytes observed on pkt_rx" severity failure;
    wait;
  end process;

  stim: process
  begin
    report "Stim process started" severity note;
    wait for 3*CLK_PERIOD;
    rst <= '0';
    wait for CLK_PERIOD;
    wait for 1 ns;
    assert req_len > 0 report "req_len still 0 after loader" severity failure;
    assert rsp_len > 0 report "rsp_len still 0 after loader" severity failure;
    report "Stim starting: req_len=" & integer'image(req_len) &
      " rsp_len=" & integer'image(rsp_len) severity note;

    for i in 0 to req_len-1 loop
      in_data  <= req_pkt(i);
      in_valid <= '1';
      wait until rising_edge(clk);
      while in_ready = '0' loop
        wait until rising_edge(clk);
      end loop;
      in_valid <= '0';
    end loop;

    while out_count < rsp_len loop
      wait until rising_edge(clk);
    end loop;

    report "tb_top_e2e completed" severity note;
    stop;
    wait;
  end process;

  rx_watch: process
  begin
    wait until rst = '0';
    wait for 1 ms;
    assert rx_seen = '1' report "rx_pkt_valid never asserted" severity failure;
    wait;
  end process;

  tx_watch: process
  begin
    wait until rst = '0';
    wait for 2 ms;
    assert tx_seen = '1' report "pkt_tx never produced output" severity failure;
    wait;
  end process;

  process (clk)
  begin
    if rising_edge(clk) then
      if rst = '1' then
        rx_seen <= '0';
        clk_edges <= 0;
      else
        clk_edges <= clk_edges + 1;
        if rx_pkt_valid = '1' then
          rx_seen <= '1';
        end if;
      end if;
    end if;
  end process;
end architecture;
